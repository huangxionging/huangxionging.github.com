<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.2.1 (452715)"/><meta name="created" content="2014-08-10 12:19:22 +0000"/><meta name="source" content="Clearly"/><meta name="source-url" content="http://ryantang.me/blog/2014/08/03/ios-prj-structure/"/><meta name="updated" content="2014-08-10 12:27:08 +0000"/><title>我的iOS工程结构 - Ryan's Zone</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
<div>
<h1>我的iOS工程结构</h1>
</div>
<p>从2011年底开始学习iOS开发，到现在也已经快3年了，虽然中途没有一直进行iOS的开发（总是在Android和iOS间切换），但始终没有离开，而我现在的工作也一样，在iOS和Android间来回游走，正如我博客的slogan一样，“In Android&amp;iOS”。其实对我来说，两个平台没有绝对的好坏，我都喜欢、我都热爱。有人会说，同样的产品在不同平台做两次不会觉得厌烦吗？这个问题我会给出肯定的回答，不会！因为如果你真的喜欢你所做的产品，做多少次都不会觉得烦，每一次的复盘都是一次改进的过程，很多创新都是在重复的工作中产生的。在技术层面，同一套思想用不同的技术来实现，本身就是一个加强对不同平台技术巩固和理解的过程，技术本来就是来承载和表现业务的，在实现业务的过程中加强对业务的理解、实现对业务的创新，这或许也就是堆代码和写程序的区别吧！^_^</p>
<h4>我的iOS工程结构</h4>
<p>接下来，我就简单介绍下我做iOS项目时使用的工程结构。首先要说的是，这只是我的工程结构，并不是规范，或许它存在很多问题和不规范的地方，我只是把它分享出来，给大家提供一个参考，也希望收到大家的一些反馈来帮助我改进！</p>
<p>下图是我做iOS项目的一个常用工程结构，整体模式还是按照MVC的结构，只是在每一层做了一些细分处理，下面就简单介绍下。</p>
<p/>
<div><img src="%E6%88%91%E7%9A%84iOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%20-%20Ryan's%20Zone.resources/90B85A06-8239-4914-B860-3ED9585F008D.png" height="0" width="0"/></div>
<p/>
<p>iOS工程中没有像Java那样非常严格的分包机制，不过在iOS工程中我们也可以通过Group的方式在工程中实现逻辑分包，这样更有利于我们组织和管理代码，使工程结构更清晰和易于理解。在我的工程结构中，主要有如下group：</p>
<ul>
<li>Application：这个group中放的是AppDelegate和一些系统常量及系统配置文件；</li>
<li>Base：一些基本父类，包括父ViewController和一些公用顶层自定义父类，其他模块的类一般都继承自这里的一些类；</li>
<li>Controller：系统控制层，放置ViewController，均继承于Group Base中的BaseViewController或BaseTableViewController；</li>
<li>View：系统中视图层，由于我比较喜欢通过代码实现界面，所以这里放的都是继承于UIView的视图，我将视图从ViewController中分离出来全部放在这里，这样能保持ViewController的精简；</li>
<li>Model：系统中的实体，通过类来描述系统中的一些角色和业务，同时包含对应这些角色和业务的处理逻辑；</li>
<li>Handler：系统业务逻辑层，负责处理系统复杂业务逻辑，上层调用者是ViewController；</li>
<li>Storage：简单数据存储，主要是一些键值对存储及系统外部文件的存取，包括对NSUserDefault和plist存取的封装；</li>
<li>Network：网络处理层(<a shape="rect" href="https://github.com/tangren03/RTLibrary-ios/blob/master/RTLibrary-ios/RTHttpClient.h" target="_blank">RTHttpClient</a>)，封装了基于AFNetworking的网络处理层，通过block实现处理结果的回调，上层调用者是Handler层；</li>
<li>Database：数据层，封装基于FMDB的sqlite数据库存取和管理(<a shape="rect" href="https://github.com/tangren03/RTLibrary-ios/blob/master/RTLibrary-ios/RTDatabaseHelper.h" target="_blank">RTDatabaseHelper</a>)，对外提供基于Model层对象的调用接口，封装对数据的存储过程。</li>
<li>Utils：系统工具类(<a shape="rect" href="https://github.com/tangren03/RTLibrary-ios/blob/master/RTLibrary-ios/AppUtils.h" target="_blank">AppUtils</a>)，主要放置一些系统常用工具类；</li>
<li>Categories：类别，对现有系统类和自定义类的扩展；</li>
<li>Resource：资源库，包括图片，plist文件等；</li>
</ul>
<p>以上是对我的工程结构中各个group的介绍，通过以下登录模块的系统类图，可以比较直观的看到这种工程结构的全貌。</p>
<p/>
<div><img src="%E6%88%91%E7%9A%84iOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%20-%20Ryan's%20Zone.resources/1F1C7A2D-72CC-40ED-9E5A-C368B1785DAD.png" height="0" width="0"/></div>
<p/>
<p>整体来看分为三大块，黄色区域的模型和业务逻辑层（M），蓝色区域的视图层（V），红色区域的视图控制器层（C），其中，黄色区域实现了对业务逻辑和数据处理的封装，对应他们的上层ViewController，可以实现非常简单的接口调用，将业务复杂性从ViewController中抽离出来，通过模块化的方式，保证ViewController的可读性和可维护性。</p>
<h5>保持ViewController简单</h5>
<p>往往大家都会抱怨iOS中ViewController写着写着就会越来越臃肿，那时因为随着业务的复杂，功能的增多，所有的逻辑都包含在ViewController中，还包括一些诸如UITableViewDatasource的代理方法，使得ViewController臃肿不堪，可维护性极低，耦合性也很高，为了使ViewController能更简单，便于维护和后续的开发，给ViewController瘦身就显得尤为必要，我的做法主要有三个方面。</p>
<h6>1、View视图与ViewController分离</h6>
<p>如果你用Storyboard或者xib这是当然的，我比较喜欢手写代码，所以不在ViewController里面嵌入过多的View层代码是保证ViewController简单的方法之一，那么，可以将View部分的代码单独封装到一个继承自UIView的子类当中，然后通过自定义Delegate实现View与ViewController的通信。</p>
<h6>2、业务逻辑与ViewController分离</h6>
<p>将网络请求处理和复杂的业务逻辑以及数据的存取工作单独放到Handler层，对ViewController只暴露简单的调用接口和通过block或delegate实现的回调，这样不仅能使我们的工程模块化，也能大大降低ViewController的复杂性，就不会出现既包括网络处理又包括数据处理的冗长的ViewController代码了。Handler通过block或delegate将处理完的结果回调给ViewController，ViewController再将结果与View视图层相关联处理，这样就真正起到了MVC的作用，整体原则就是，让ViewController只关系和负责处理与它相关的事。</p>
<p>在BaseHandler.h中可以定义一些简单的业务处理规则：</p>
BaseHandler.h
<div>
<table>
<tr>
<td colspan="1" rowspan="1"/>
<td colspan="1" rowspan="1">
<pre>
<code>#import &lt;Foundation/Foundation.h&gt;
 *  Handler处理完成后调用的Block
typedef  CompleteBlock
 *  Handler处理成功时调用的Block
typedef  SuccessBlock 
 *  Handler处理失败时调用的Block
typedef  FailedBlock 
interface BaseHandler  NSObject
 *  获取请求URL
 *  @param path
 *  @return 拼装好的URL
 NSString requestUrlWithPathNSString 
</code>
</pre></td>
</tr>
</table>
</div>
<p>在LoginHandler中就可以定义对LoginViewController暴露的调用接口，在LoginHandler中封装负责的网络处理和业务处理逻辑，对LoginViewcontroller来说，只需要调用这个方法并传入对应的UserEntity实体对象和处理成功和失败状态下的回调block就可以了。</p>
LoginHandler.h
<div>
<table>
<tr>
<td colspan="1" rowspan="1"/>
<td colspan="1" rowspan="1">
<pre>
<code>#import "BaseHandler.h"
#import "UserEntity.h"
interface LoginHandler  BaseHandler
 *  用户登录业务逻辑处理
 *  @param user
 *  @param success
 *  @param failed  
 executeLoginTaskWithUserUserEntity  successSuccessBlocksuccess failedFailedBlockfailed
</code>
</pre></td>
</tr>
</table>
</div>
<h6>3、Datasource或Delegate与ViewController分离</h6>
<p>在iOS开发中经常用到的UITableView包含了一系列的代理方法，这些方法往往也是使得ViewController变长变复杂的元凶之一，那么，将这些Datasource或Delegate分离出来也是行之有效的方法之一，例如，通过自定义Datasource类（实现UITableViewDatasource协议）来将跟UITableView相关的数据源处理代理方法都集中到一个特定的类当中，ViewController只需要设置这个自定义数据源类给UITableView，然后其他的就都可以交给自定义数据源类去处理了。</p>
<p>我参考了<a shape="rect" href="http://www.objc.io/issue-1/lighter-view-controllers.html" target="_blank">Lighter View Controllers</a>上的介绍改进了一个<code>BaseTableViewProtocol</code>，基本上常用的一些场景是可以使用的，不过这个还得不断优化以适应更多的场景，具体的代码我放在Github上了，感兴趣的同学可以去看看，使用方法可以参考上面链接中的介绍，基本类似，我的改进主要是支持对多section的适用。</p>
<p>以上是我在开发iOS项目中的一些总结和工程实践，其中肯定还是存在很多问题的，我也在不断寻求改进的方法，也欢迎各路高手给我提出意见和建议。关于这个工程结构的一个简单事例我放在我的Github上了，感兴趣的同学可以去看看<a shape="rect" href="https://github.com/tangren03/RTLibrary-ios" target="_blank">RTLibrary-ios</a>。</p>
</body></html>